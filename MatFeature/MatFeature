/*
 * @Author: LetMeFly
 * @Date: 2022-04-26 11:58:33
 * @LastEditors: LetMeFly
 * @LastEditTime: 2022-04-26 14:25:11
 */
#ifndef MATFEATURE_H
#define MATFEATURE_H

#include <MatFeature/Test>
#include <Eigen/Dense>
using Eigen::MatrixXd;

#define RETURN_IF_CALCULATED \
    static bool first = true;\
    static vector<double> ans;\
    if (first)\
        first = false;\
    else\
        return ans;


class MatFeature {
private:
    MatrixXd mat;
public:
    MatFeature(MatrixXd mat) : mat(mat) {};
    vector<double> maximum();  // 最大值
    vector<double> minimum();  // 最小值
    vector<double> mean();  // 平均值
    vector<double> peak();  // 峰-峰值
    vector<double> ma();  // 平均幅值
    vector<double> var();  // 方差
    vector<double> std();  // 标准差
    vector<double> kurtosis();  // 峭度
};

vector<double> MatFeature::maximum() {
    RETURN_IF_CALCULATED
    for (int j = 0; j < mat.cols(); j++) {
        double M = 0;  // 若空返回0
        if (mat.rows()) {
            M = mat(0, j);
            for (int i = 1; i < mat.rows(); i++) {
                M = max(M, mat(i, j));
            }
        }
        ans.push_back(M);
    }
    return ans;
}

vector<double> MatFeature::minimum() {
    RETURN_IF_CALCULATED
    for (int j = 0; j < mat.cols(); j++) {
        double M = 0;  // 若空返回0
        if (mat.rows()) {
            M = mat(0, j);
            for (int i = 1; i < mat.rows(); i++) {
                M = min(M, mat(i, j));
            }
        }
        ans.push_back(M);
    }
    return ans;
}


vector<double> MatFeature::mean() {
    RETURN_IF_CALCULATED
    for (int j = 0; j < mat.cols(); j++) {
        double s = 0;  // 若空返回0
        if (mat.rows()) {
            for (int i = 0; i < mat.rows(); i++) {
                s += mat(i, j);
            }
            s /= mat.rows();
        }
        ans.push_back(s);
    }
    return ans;
}

vector<double> MatFeature::peak() {
    RETURN_IF_CALCULATED
    vector<double> Maximum = maximum();
    vector<double> Minimum = minimum();
    for (int j = 0; j < mat.cols(); j++) {
        ans.push_back(Maximum[j] - Minimum[j]);
    }
    return ans;
}

vector<double> MatFeature::ma() {
    RETURN_IF_CALCULATED
    for (int j = 0; j < mat.cols(); j++) {
        double s = 0;  // 若空返回0
        if (mat.rows()) {
            for (int i = 0; i < mat.rows(); i++) {
                s += abs(mat(i, j));
            }
            s /= mat.rows();
        }
        ans.push_back(s);
    }
    return ans;
}

vector<double> MatFeature::var() {
    RETURN_IF_CALCULATED
    vector<double> miu = mean();
    for (int j = 0; j < mat.cols(); j++) {
        double s = 0;  // 若空返回0
        if (mat.rows()) {
            for (int i = 0; i < mat.rows(); i++) {
                s += pow(mat(i, j) - miu[j], 2);
            }
            s /= mat.rows();
        }
        ans.push_back(s);
    }
    return ans;
}

vector<double> MatFeature::std() {
    RETURN_IF_CALCULATED
    ans = var();
    for (auto& t : ans) {
        t = sqrt(t);
    }
    return ans;
}

vector<double> MatFeature::kurtosis() {
    RETURN_IF_CALCULATED
    for (int j = 0; j < mat.cols(); j++) {
        double s = 0;  // 若空返回0
        if (mat.rows()) {
            for (int i = 0; i < mat.rows(); i++) {
                s += pow(mat(i, j), 4);
            }
            s /= mat.rows();
        }
        ans.push_back(s);
    }
    return ans;
}

#endif